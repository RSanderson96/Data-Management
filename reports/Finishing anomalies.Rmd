---
title: "The Anomaly of Finishers"
author: "Rachael Sanderson"
date: "13 November 2019"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir= normalizePath('..'))
library(ProjectTemplate)

```

```{r load_project, include = FALSE}
load.project()

```

As was acknowledged, the previous section considered how certain steps had a greater number of non-finishers than the step following them, implying that 'not finishing' a step is not the equivalent to not completing further steps. Following this realisation, an alternative route of analysis was considered, focusing on learner IDs and the number of times they are recorded as 'non-finishing'. 

#How many times are individual IDs recorded as non-finishers?
The initial analysis focused on how many times people were recorded as not finishing a step using the following formula

```{R Non_finish}
Incomplete_Quantity= cyber.security.7.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
```


This created a data frame that showed how many times each learner ID failed to complete a step:

```{R ShowDF, echo = FALSE}
Incomplete_Quantity
```

Following from this, it is possible to display how many individual IDs had non - finishing steps;

```{R DataFrames, include=FALSE}
Incomplete_Quantity1= cyber.security.1.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity2= cyber.security.2.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity3= cyber.security.3.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity4= cyber.security.4.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity5= cyber.security.5.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity6= cyber.security.6.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity7= cyber.security.7.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)



```


```{R Run_Non_Finish}
IncompleteDF = data.frame(Course1 = nrow(Incomplete_Quantity1),Course2 = nrow(Incomplete_Quantity2),
                          Course3 = nrow(Incomplete_Quantity3),Course4 = nrow(Incomplete_Quantity4),
                          Course5 = nrow(Incomplete_Quantity5),Course6 = nrow(Incomplete_Quantity6),
                          Course7 = nrow(Incomplete_Quantity7))

IncompleteDF
```


#Considering a Specific Group
The first group of non-finishers considered were those that only had one incident of an infinished step; these are individuals who are more likely to have not continued, making it a more accurate statistic for reflections on rate of dropout. 

Firstly, a function was made to identify these learners, before creating a data frame that matched these individuals to their only unfinished step:

```{R SingleUnfinish.Function}

 SingleUnfinish.Function=function(x){
   StepActivity = x
   Incomplete_Quantity= StepActivity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
   Incomplete_Single = Incomplete_Quantity%>% filter(n == 1)
   L = nrow(Incomplete_Single) #making the DF of "one step unfinished"
   
   Steps=c((StepActivity$week_number)+((StepActivity$step_number)/100)) #acknowledging data complication
   StepActivity = cbind(StepActivity, Steps) #correcting the steps confusion
   
   Learner = vector() #make the vector
   for(i in 1:L){ 
   ID = (StepActivity %>% filter(learner_id == Incomplete_Single$learner_id[i])%>% filter(last_completed_at == ""))
    #Pick out the ID from the dataframe that has been identified as only having one stage unfinished
   Learner [i]= ID$Steps} #Which step was unfinished?
   LearnerSingleDF = data.frame(Learner = Incomplete_Single$learner_id, Step = Learner)
   UnfinishedSteps = LearnerSingleDF%>% count(Step) %>% arrange(-n)
   return(UnfinishedSteps)
 }

```

This formula was applied to each step activity file, with the final amounts pulled into one singluar data frame:

```{R Making_Dataframes, include=FALSE}
LargeDF = merge.data.frame(Single1, Single2, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_1 = n.x, Run_2 = n.y )
LargeDF = merge.data.frame(LargeDF, Single3, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_3 = n)
LargeDF = merge.data.frame(LargeDF, Single4, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_4 = n)
LargeDF = merge.data.frame(LargeDF, Single5, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_5 = n)
LargeDF = merge.data.frame(LargeDF, Single6, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_6 = n)
LargeDF = merge.data.frame(LargeDF, Single7, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_7 = n)

LargeDF
```

The final result was a model in the form of the following graph:

```{R UnfinishedGraph, echo = FALSE}
U = ggplot(data = LargeDF, aes(x = Step, y=Total))
U1 = U + geom_point (aes(x = Step, y=Run_1, colour = "Course1"))
U2 = U1 + geom_point (aes(x = Step, y=Run_2, colour = "Course2"))
U3 = U2 + geom_point (aes(x = Step, y=Run_3, colour = "Course3"))
U4 = U3 + geom_point (aes(x = Step, y=Run_4, colour = "Course4"))
U5 = U4 + geom_point (aes(x = Step, y=Run_5, colour = "Course5"))
U6 = U5 + geom_point (aes(x = Step, y=Run_6, colour = "Course6"))
U7 = U6 + geom_point (aes(x = Step, y=Run_7, colour = "Course7"))

U7

#See number that drop at the start
#remove missing values?
```

#An Indication of Course Engagement?
This next section will consider whether not completing steps means a lack of course engagement. 

Firstly, a formula was produced to compare the number of unfinished steps by a specific learner ID, and their engagement with the quiz section in the course;

```{R Unfinished_Formula}
UnfinishLeaner.function = function(x,y){
  
  Incomplete_Quantity = x%>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
  #Filter: Number of non-finishes by learner

  Count_Unfinished = (merge(y, Incomplete_Quantity, by = "learner_id"))%>%filter(n != "")
  #dataframe = Question responses & counts the number of unfinished steps for each learner ID
  
  Answers= y %>% filter(correct == "true") %>% count(learner_id) %>% arrange(-n)
  #how many correct answers for each learner ID?
  Attempts =y %>% count(learner_id) %>% arrange(-n)
  #How many attempts for each learner ID?
  
  #Now make the data frame that has only unique learner IDS, and add columns for answers and attempts:
  Unfinished = data.frame(learner_id = Count_Unfinished$learner_id, Unfinished = Count_Unfinished$n)
  Unfinished = unique.data.frame(Unfinished)
  UnfinishedQuestions = merge(Unfinished,Answers, by = "learner_id", all = TRUE)
  UnfinishedQuestions = UnfinishedQuestions%>% rename(Correct_Answers = n)
  UnfinishedQuestions = merge(UnfinishedQuestions,Attempts, by = "learner_id", all = TRUE)
  UnfinishedQuestions = UnfinishedQuestions%>% rename(Quant_Attempts = n)
  
  #Calculate the proportion of correct answers per learner ID, and add this to the existing dataframe:
  ProportionCorrect = (UnfinishedQuestions$Correct_Answers/UnfinishedQuestions$Quant_Attempts)*100
  UnfinishedQuestions = cbind(UnfinishedQuestions, ProportionCorrect)
  #Final result: Completed data frame
  return(UnfinishedQuestions)}
```

The final result is a data frame that for each ID shows the number of unfinished steps, the number of question attempts, the number of correct answers, and the proportion of correct answers from questions attempted.


T = ggplot(data = Unfinished7, aes(x = Unfinished, y = ProportionCorrect))
T1 = T + geom_point(aes(x = Unfinished, y = ProportionCorrect))

#add more years???
