---
title: "The Anomaly of Finishers"
author: "Rachael Sanderson"
date: "13 November 2019"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir= normalizePath('..'))
library(ProjectTemplate)

```

```{r load_project, include = FALSE}
load.project()

```

As was acknowledged, the previous section considered how certain steps had a greater number of non-finishers than the step following them, implying that 'not finishing' a step is not the equivalent to not completing further steps. Following this realisation, an alternative route of analysis was considered, focusing on learner IDs and the number of times they are recorded as 'non-finishing'. 

#How many times are individual IDs recorded as non-finishers?
The initial analysis focused on how many times people were recorded as not finishing a step using the following formula

```{R Non_finish}
Incomplete_Quantity= cyber.security.7.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
```


This created a data frame that showed how many times each learner ID failed to complete a step:

```{R ShowDF, echo = FALSE}
Incomplete_Quantity
```

Following from this, it is possible to display how many individual IDs had non - finishing steps;

```{R DataFrames, include=FALSE}
Incomplete_Quantity1= cyber.security.1.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity2= cyber.security.2.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity3= cyber.security.3.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity4= cyber.security.4.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity5= cyber.security.5.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity6= cyber.security.6.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
Incomplete_Quantity7= cyber.security.7.step.activity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)



```


```{R Run_Non_Finish}
IncompleteDF = data.frame(Course1 = nrow(Incomplete_Quantity1),Course2 = nrow(Incomplete_Quantity2),
                          Course3 = nrow(Incomplete_Quantity3),Course4 = nrow(Incomplete_Quantity4),
                          Course5 = nrow(Incomplete_Quantity5),Course6 = nrow(Incomplete_Quantity6),
                          Course7 = nrow(Incomplete_Quantity7))

IncompleteDF
```


#Considering a Specific Group
The first group of non-finishers considered were those that only had one incident of an infinished step; these are individuals who are more likely to have not continued, making it a more accurate statistic for reflections on rate of dropout. 

Firstly, a function was made to identify these learners, before creating a data frame that matched these individuals to their only unfinished step:

```{R SingleUnfinish.Function}

 SingleUnfinish.Function=function(x){
   StepActivity = x
   Incomplete_Quantity= StepActivity %>% filter(last_completed_at == "") %>% count(learner_id) %>% arrange(-n)
   Incomplete_Single = Incomplete_Quantity%>% filter(n == 1)
   L = nrow(Incomplete_Single) #making the DF of "one step unfinished"
   
   Steps=c((StepActivity$week_number)+((StepActivity$step_number)/100)) #acknowledging data complication
   StepActivity = cbind(StepActivity, Steps) #correcting the steps confusion
   
   Learner = vector() #make the vector
   for(i in 1:L){ 
   ID = (StepActivity %>% filter(learner_id == Incomplete_Single$learner_id[i])%>% filter(last_completed_at == ""))
    #Pick out the ID from the dataframe that has been identified as only having one stage unfinished
   Learner [i]= ID$Steps} #Which step was unfinished?
   LearnerSingleDF = data.frame(Learner = Incomplete_Single$learner_id, Step = Learner)
   UnfinishedSteps = LearnerSingleDF%>% count(Step) %>% arrange(-n)
   return(UnfinishedSteps)
 }

```

This formula was applied to each step activity file, with the final amounts pulled into one singluar data frame:

```{R Making_Dataframes, include=FALSE}
LargeDF = merge.data.frame(Single1, Single2, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_1 = n.x, Run_2 = n.y )
LargeDF = merge.data.frame(LargeDF, Single3, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_3 = n)
LargeDF = merge.data.frame(LargeDF, Single4, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_4 = n)
LargeDF = merge.data.frame(LargeDF, Single5, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_5 = n)
LargeDF = merge.data.frame(LargeDF, Single6, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_6 = n)
LargeDF = merge.data.frame(LargeDF, Single7, by = "Step", all=TRUE)
LargeDF = LargeDF%>% rename(Run_7 = n)

LargeDF
```

The final result was a model in the form of the following graph:

```{R UnfinishedGraph, echo = FALSE}
U = ggplot(data = LargeDF, aes(x = Step, y=Total))
U1 = U + geom_point (aes(x = Step, y=Run_1, colour = "Course1"))
U2 = U1 + geom_point (aes(x = Step, y=Run_2, colour = "Course2"))
U3 = U2 + geom_point (aes(x = Step, y=Run_3, colour = "Course3"))
U4 = U3 + geom_point (aes(x = Step, y=Run_4, colour = "Course4"))
U5 = U4 + geom_point (aes(x = Step, y=Run_5, colour = "Course5"))
U6 = U5 + geom_point (aes(x = Step, y=Run_6, colour = "Course6"))
U7 = U6 + geom_point (aes(x = Step, y=Run_7, colour = "Course7"))

U7

#See number that drop at the start
```


